---
layout: default
---
# 题目

![Untitled](%E9%A2%98%E7%9B%AE%2025b98965f14f4ab0857d73fdc9e1ac04/Untitled.png)

B。只是每条边存两次而已，不是不存；

![Untitled](%E9%A2%98%E7%9B%AE%2025b98965f14f4ab0857d73fdc9e1ac04/Untitled%201.png)

C。

![Untitled](%E9%A2%98%E7%9B%AE%2025b98965f14f4ab0857d73fdc9e1ac04/Untitled%202.png)

D。矩阵大小为$n^2$，有 2e 个占上了🧐

![Untitled](%E9%A2%98%E7%9B%AE%2025b98965f14f4ab0857d73fdc9e1ac04/Untitled%203.png)

D。0 和♾️都不是有向边🧐

![Untitled](%E9%A2%98%E7%9B%AE%2025b98965f14f4ab0857d73fdc9e1ac04/Untitled%204.png)

B，D。第i列的非 0 元素之和，则 i 不动；无向图列行都可以🧐

![Untitled](%E9%A2%98%E7%9B%AE%2025b98965f14f4ab0857d73fdc9e1ac04/Untitled%205.png)

B。

![Untitled](%E9%A2%98%E7%9B%AE%2025b98965f14f4ab0857d73fdc9e1ac04/Untitled%206.png)

![Untitled](%E9%A2%98%E7%9B%AE%2025b98965f14f4ab0857d73fdc9e1ac04/Untitled%207.png)

B，B，D

![Untitled](%E9%A2%98%E7%9B%AE%2025b98965f14f4ab0857d73fdc9e1ac04/Untitled%208.png)

B。

![Untitled](%E9%A2%98%E7%9B%AE%2025b98965f14f4ab0857d73fdc9e1ac04/Untitled%209.png)

A。

![Untitled](%E9%A2%98%E7%9B%AE%2025b98965f14f4ab0857d73fdc9e1ac04/Untitled%2010.png)

D。无向图因为记两次一定是偶数

![Untitled](%E9%A2%98%E7%9B%AE%2025b98965f14f4ab0857d73fdc9e1ac04/Untitled%2011.png)

C。邻接表中边表是被插的结点，与顶点表构成弧，因此出现几次与被插的次数有关

![Untitled](%E9%A2%98%E7%9B%AE%2025b98965f14f4ab0857d73fdc9e1ac04/Untitled%2012.png)

B。

![Untitled](%E9%A2%98%E7%9B%AE%2025b98965f14f4ab0857d73fdc9e1ac04/Untitled%2013.png)

C。先删除出边，把顶点 v 对应一根链表都删了，最多有n-1个，则O(n)，再遍历所有边把入边删了，这个过程中需要先扫描顶点，再走边，故需要O(n+e)，最终总共O(n+e)🧐

![Untitled](%E9%A2%98%E7%9B%AE%2025b98965f14f4ab0857d73fdc9e1ac04/Untitled%2014.png)

D。A 就是结点数，不用 2 倍，无向图不区分出度入度

![Untitled](%E9%A2%98%E7%9B%AE%2025b98965f14f4ab0857d73fdc9e1ac04/Untitled%2015.png)

A。

![Untitled](%E9%A2%98%E7%9B%AE%2025b98965f14f4ab0857d73fdc9e1ac04/Untitled%2016.png)

B。

![Untitled](%E9%A2%98%E7%9B%AE%2025b98965f14f4ab0857d73fdc9e1ac04/Untitled%2017.png)

算法思想：遍历邻接表，设邻接表顶点表为`adjListv[n]`,则遍历adjListv[i]的边表时，若遍历到结点的值是j，将邻接矩阵 `adjMatrix[i][j]` 的值置为 1，遍历完邻接表时算法结束

```cpp
void Convert_List_to_Matrix(adjList G,int adjMatrix[M][N]){
//此算法将邻接表表示的图 G 转换为邻接矩阵 adjMatrix
		for(int i = 0;i < n;++i){  //依次遍历各顶点连接的边表
				p = G->adjListv[i].firstEdge; //第一条（出）边 
				while(p!=NULL){  //遍历完整条边链表
						adjMatrix[i][p->adjvex] = 1;//将矩阵中当前对应弧置为 1
						p = p->nextarc;  //进入下一条（出）边
				}//while
		}//for
}
```

![Untitled](%E9%A2%98%E7%9B%AE%2025b98965f14f4ab0857d73fdc9e1ac04/Untitled%2018.png)

算法思想：判断 G 是否满足度为奇数的顶点个数为不大于 2 的偶数。设度为奇数的顶点个数为 num；遍历邻接矩阵的每一行，当第 i 行的非零元素和为奇数时，num增加 1。当遍历完所有行时，判断 num 的值是否为 0 或 2，如果是则存在 EL 路径，返回 1；反之返回 0。

```cpp
int IsExistEL(MGraph G){
//算法将判断邻接矩阵表示的无向图G中是否含有EL路径
		int num = 0;  //将度为奇数的顶点个数初始化为 0
		int degree = 0;  //遍历时要计算该顶点的度
		for(int i = 0;i < G->numVertices;i++){  //遍历所有的顶点
				degree = 0;  //每次开始时将度初始化为 0
				for(int j = 0;j < G->numVertices;j++)  //遍历顶点i可能邻接的所有边
						++degree;  //计算度的和
					if(degree % 2 != 0) ++num;  //当度数满足条件个数加 1
		} //for
		if(num == 0 || num == 2)
				return 1;  //判断个数，存在返回 1
		else 
				return 0;  //不存在，返回 0
}			
```

时间复杂度：遍历整个邻接矩阵，$O(n^2)$，空间复杂度：原地进行$O(1)$