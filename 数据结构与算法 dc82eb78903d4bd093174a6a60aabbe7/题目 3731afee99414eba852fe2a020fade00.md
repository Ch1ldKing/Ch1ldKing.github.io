# 题目

- 导航
    
    [定义](%E9%A2%98%E7%9B%AE%203731afee99414eba852fe2a020fade00.md)
    
    [单链表](%E9%A2%98%E7%9B%AE%203731afee99414eba852fe2a020fade00.md)
    
    [双链表](%E9%A2%98%E7%9B%AE%203731afee99414eba852fe2a020fade00.md)
    
    [静态链表](%E9%A2%98%E7%9B%AE%203731afee99414eba852fe2a020fade00.md)
    

定义

![Untitled](%E9%A2%98%E7%9B%AE%203731afee99414eba852fe2a020fade00/Untitled.png)

B。链式表示逻辑结构更方便。3 说反了，4 顺序两种都能，链式只能顺序

![Untitled](%E9%A2%98%E7%9B%AE%203731afee99414eba852fe2a020fade00/Untitled%201.png)

B。

单链表

![Untitled](%E9%A2%98%E7%9B%AE%203731afee99414eba852fe2a020fade00/Untitled%202.png)

C。

![Untitled](%E9%A2%98%E7%9B%AE%203731afee99414eba852fe2a020fade00/Untitled%203.png)

D。树也能用顺序，顺序表与 i 大小无关，4 查找插入位置是O(n)

![Untitled](%E9%A2%98%E7%9B%AE%203731afee99414eba852fe2a020fade00/Untitled%204.png)

A。查找废的时间一样，但是链表删比顺序表容易

![Untitled](%E9%A2%98%E7%9B%AE%203731afee99414eba852fe2a020fade00/Untitled%205.png)

C。

![Untitled](%E9%A2%98%E7%9B%AE%203731afee99414eba852fe2a020fade00/Untitled%206.png)

D。如果直接插入排序，每次插入都要遍历链表，O(n^2)。如果先对数组排序，再做有序链表：做有序链表的为O(n)，数组排序最好的为快排等，为O(nlog_2n)

![Untitled](%E9%A2%98%E7%9B%AE%203731afee99414eba852fe2a020fade00/Untitled%207.png)

C。单链表需要遍历到结尾，再接上，所以 m。

![Untitled](%E9%A2%98%E7%9B%AE%203731afee99414eba852fe2a020fade00/Untitled%208.png)

![Untitled](%E9%A2%98%E7%9B%AE%203731afee99414eba852fe2a020fade00/Untitled%209.png)

C。首先，有头结点可以统一元素增删操作，无需单独考虑头结点元素。其次，有头结点使链表是否为空都有头指针，统一空表和非空表。

![Untitled](%E9%A2%98%E7%9B%AE%203731afee99414eba852fe2a020fade00/Untitled%2010.png)

B。最后一个元素的删除只能依靠前驱结点，不能与后续结点交换数据域。因此要遍历到倒数第二个元素进行删除。

![Untitled](%E9%A2%98%E7%9B%AE%203731afee99414eba852fe2a020fade00/Untitled%2011.png)

B，A。

![Untitled](%E9%A2%98%E7%9B%AE%203731afee99414eba852fe2a020fade00/Untitled%2012.png)

B。查找要 n

![Untitled](%E9%A2%98%E7%9B%AE%203731afee99414eba852fe2a020fade00/Untitled%2013.png)

D。如果空链表，head→next→next就是head→next就是head;如果有一个元素，也成立

![Untitled](%E9%A2%98%E7%9B%AE%203731afee99414eba852fe2a020fade00/Untitled%2014.png)

C。

![Untitled](%E9%A2%98%E7%9B%AE%203731afee99414eba852fe2a020fade00/Untitled%2015.png)

![Untitled](%E9%A2%98%E7%9B%AE%203731afee99414eba852fe2a020fade00/Untitled%2016.png)

D。特殊考虑只有一个元素的情况。

双链表

![Untitled](%E9%A2%98%E7%9B%AE%203731afee99414eba852fe2a020fade00/Untitled%2017.png)

C。双链表能很方便的访问前驱和后继

![Untitled](%E9%A2%98%E7%9B%AE%203731afee99414eba852fe2a020fade00/Untitled%2018.png)

D。注意的就是不能先改p→prior，要不前驱就丢了

![Untitled](%E9%A2%98%E7%9B%AE%203731afee99414eba852fe2a020fade00/Untitled%2019.png)

A。只要前后继不丢就行。

![Untitled](%E9%A2%98%E7%9B%AE%203731afee99414eba852fe2a020fade00/Untitled%2020.png)

D。最恰当

![Untitled](%E9%A2%98%E7%9B%AE%203731afee99414eba852fe2a020fade00/Untitled%2021.png)

D。

![Untitled](%E9%A2%98%E7%9B%AE%203731afee99414eba852fe2a020fade00/Untitled%2022.png)

A。双循环链表可以更方便找前驱。

![Untitled](%E9%A2%98%E7%9B%AE%203731afee99414eba852fe2a020fade00/Untitled%2023.png)

C。A，C 好像都能，但是 A 的话删除尾结点元素需要找前驱。可能你会说可以与后面结点交换数据域，但是那是特殊方法

![Untitled](%E9%A2%98%E7%9B%AE%203731afee99414eba852fe2a020fade00/Untitled%2024.png)

C。

![Untitled](%E9%A2%98%E7%9B%AE%203731afee99414eba852fe2a020fade00/Untitled%2025.png)

D。

静态链表

![Untitled](%E9%A2%98%E7%9B%AE%203731afee99414eba852fe2a020fade00/Untitled%2026.png)

C。

![Untitled](%E9%A2%98%E7%9B%AE%203731afee99414eba852fe2a020fade00/Untitled%2027.png)

B。