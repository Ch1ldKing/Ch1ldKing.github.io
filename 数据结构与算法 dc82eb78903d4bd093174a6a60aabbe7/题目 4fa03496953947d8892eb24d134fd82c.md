---
layout: default
---
# 题目

- 导航
    
    [定义](%E9%A2%98%E7%9B%AE%204fa03496953947d8892eb24d134fd82c.md)
    
    [时间复杂度](%E9%A2%98%E7%9B%AE%204fa03496953947d8892eb24d134fd82c.md)
    
    [位置](%E9%A2%98%E7%9B%AE%204fa03496953947d8892eb24d134fd82c.md)
    
    [算法](%E9%A2%98%E7%9B%AE%204fa03496953947d8892eb24d134fd82c.md)
    

定义

![Untitled](%E9%A2%98%E7%9B%AE%204fa03496953947d8892eb24d134fd82c/Untitled.png)

A。增删方便是链表优点，D 比如树就链表比顺序表好

![Untitled](%E9%A2%98%E7%9B%AE%204fa03496953947d8892eb24d134fd82c/Untitled%201.png)

A。随机存取指的就是，起始地址加元素序号，访问任意一个元素

![Untitled](%E9%A2%98%E7%9B%AE%204fa03496953947d8892eb24d134fd82c/Untitled%202.png)

B。存储空间=表长*sizeof（元素类型）

时间复杂度

![Untitled](%E9%A2%98%E7%9B%AE%204fa03496953947d8892eb24d134fd82c/Untitled%203.png)

D。有元素位置序号

![Untitled](%E9%A2%98%E7%9B%AE%204fa03496953947d8892eb24d134fd82c/Untitled%204.png)

A。表尾增删无需移动，随机存取

![Untitled](%E9%A2%98%E7%9B%AE%204fa03496953947d8892eb24d134fd82c/Untitled%205.png)

C。除了表尾，其他的增删都需要移动元素。有序号的访问是O(1)

![Untitled](%E9%A2%98%E7%9B%AE%204fa03496953947d8892eb24d134fd82c/Untitled%206.png)

C。这里说下 2，先遍历到 3和 4，断开并记录地址，4 接到 2 后面，再把 4 后面断开并记录，把 3 接上再接后面的。而顺序表只需要temp=4，4=3，3=temp

![Untitled](%E9%A2%98%E7%9B%AE%204fa03496953947d8892eb24d134fd82c/Untitled%207.png)

C。从$a_{i+1}$～$a_n$，共$n-(i+1)+1$个元素。

![Untitled](%E9%A2%98%E7%9B%AE%204fa03496953947d8892eb24d134fd82c/Untitled%208.png)

C。

位置

![Untitled](%E9%A2%98%E7%9B%AE%204fa03496953947d8892eb24d134fd82c/Untitled%209.png)

B。在表尾插是n+1。

![Untitled](%E9%A2%98%E7%9B%AE%204fa03496953947d8892eb24d134fd82c/Untitled%2010.png)

D。顺序表需要连续的存储空间

算法

![Untitled](%E9%A2%98%E7%9B%AE%204fa03496953947d8892eb24d134fd82c/Untitled%2011.png)

```cpp
bool Del_Min(sqList &L, ElemType min) 
// 删除表 L 中的元素，并通过引用参数 min 返回此值
{

    if (L.length == 0)
    {
        cerr << "Empty!" << endl; // 表空，输出错误信息并退出
        return false;
    }
    min = L.data[0]; // 假设最小元素是表头
    int pos;
    for (pos = 1; pos <= L.length; pos++) // 记录最小元素位置pos
    {
        if (L.data[pos] < min)
        {
            min = L.data[pos]; // 将min更新为最小元素
        }
    }
    L.data[pos] = L.data[L.length - 1]; // 将当前空位置由最后一个元素替代
    L.length--;
    return true; //此时 min 即为最小值
}
```

![Untitled](%E9%A2%98%E7%9B%AE%204fa03496953947d8892eb24d134fd82c/Untitled%2012.png)

```cpp
void(SqList &L)
{
    int temp; // 辅助暂存变量
    for (int i = 0; i < L.length / 2; i++)
    {
        temp = L.data[i];
        L.data[i] = L.data[L.length - 1 - i]; // 交换前后对称的两个元素
        L.data[L.length - 1 - i] = temp;
    }
}
```

![Untitled](%E9%A2%98%E7%9B%AE%204fa03496953947d8892eb24d134fd82c/Untitled%2013.png)