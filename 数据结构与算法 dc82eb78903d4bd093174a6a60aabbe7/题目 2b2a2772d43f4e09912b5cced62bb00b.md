---
layout: default
---
# 题目

定义及操作

![Untitled](%E9%A2%98%E7%9B%AE%202b2a2772d43f4e09912b5cced62bb00b/Untitled.png)

D。

![Untitled](%E9%A2%98%E7%9B%AE%202b2a2772d43f4e09912b5cced62bb00b/Untitled%201.png)

B。

![Untitled](%E9%A2%98%E7%9B%AE%202b2a2772d43f4e09912b5cced62bb00b/Untitled%202.png)

D。

![Untitled](%E9%A2%98%E7%9B%AE%202b2a2772d43f4e09912b5cced62bb00b/Untitled%203.png)

B。A 对于队列是多余的，链表本来就不怕溢出，这么一整增删完了还得链上变成循环。

![Untitled](%E9%A2%98%E7%9B%AE%202b2a2772d43f4e09912b5cced62bb00b/Untitled%204.png)

A。

![Untitled](%E9%A2%98%E7%9B%AE%202b2a2772d43f4e09912b5cced62bb00b/Untitled%205.png)

A。

![Untitled](%E9%A2%98%E7%9B%AE%202b2a2772d43f4e09912b5cced62bb00b/Untitled%206.png)

D。如果队列中只有一个元素的话，那么要`rear=front` 🧐

![Untitled](%E9%A2%98%E7%9B%AE%202b2a2772d43f4e09912b5cced62bb00b/Untitled%207.png)

D。

![Untitled](%E9%A2%98%E7%9B%AE%202b2a2772d43f4e09912b5cced62bb00b/Untitled%208.png)

A。由于循环链表在入队后也得循环，必须将表尾元素指向新第一个元素，只设头指针的情况下，遍历到尾指针需要 O(n)。🧐

顺序问题

![Untitled](%E9%A2%98%E7%9B%AE%202b2a2772d43f4e09912b5cced62bb00b/Untitled%209.png)

B。

![Untitled](%E9%A2%98%E7%9B%AE%202b2a2772d43f4e09912b5cced62bb00b/Untitled%2010.png)

D。MaxSize= n+1

![Untitled](%E9%A2%98%E7%9B%AE%202b2a2772d43f4e09912b5cced62bb00b/Untitled%2011.png)

C。（rear-front+MaxSize）%MaxSize =16

![Untitled](%E9%A2%98%E7%9B%AE%202b2a2772d43f4e09912b5cced62bb00b/Untitled%2012.png)

![Untitled](%E9%A2%98%E7%9B%AE%202b2a2772d43f4e09912b5cced62bb00b/Untitled%2013.png)

B。入队出队都是+1。🧐

![Untitled](%E9%A2%98%E7%9B%AE%202b2a2772d43f4e09912b5cced62bb00b/Untitled%2014.png)

C。是 rear 在 front 前一个，所以是 rear+1，而不是 front。🧐

![Untitled](%E9%A2%98%E7%9B%AE%202b2a2772d43f4e09912b5cced62bb00b/Untitled%2015.png)

C。排除法。颅内开队列，1234 可以从不同位置进：A 肯定可以，B 同一端进，右出一下左出一下，D 如果你两边都能进，那你就只有一边能出。左 1 右 2 左 3 右 4，都从右出就是 4213。C 怎么也想不出来，输入受限做不到 4 后面是 2，输出受限做不到最后一个出来的是 1 的同时其他元素还不按顺序。

![Untitled](%E9%A2%98%E7%9B%AE%202b2a2772d43f4e09912b5cced62bb00b/Untitled%2016.png)

C。输出受限，输进去啥样就啥样了，只要挨个看能不能这么输进去（从左右放，想象脑子里有根横着的管子）

![Untitled](%E9%A2%98%E7%9B%AE%202b2a2772d43f4e09912b5cced62bb00b/Untitled%2017.png)

B。队列非空时指向元素，这一点和正常的队列不同。因此 rear 是入队后才到0，front 指向队头与普通的队列一致，因此 （rear+1）%maxsize后才为 0🧐

![Untitled](%E9%A2%98%E7%9B%AE%202b2a2772d43f4e09912b5cced62bb00b/Untitled%2018.png)

![Untitled](%E9%A2%98%E7%9B%AE%202b2a2772d43f4e09912b5cced62bb00b/Untitled%2019.png)

A。队满：假设存储在0~M-2 的区域，那么front在 0，rear在 M-1，则（M-1+1）取余就是 0

![Untitled](%E9%A2%98%E7%9B%AE%202b2a2772d43f4e09912b5cced62bb00b/Untitled%2020.png)

C。我的理解是，你出去的时候，每条轨道上都得是逆序的，这种情况下用最少的轨道就行。肯定先从 1 开始看，想象一排数761935248在左边排队，一条轨道上是 761，一条是 954，一条是 632，一条是 8；或者一条是 761，一条 932，一条 54，一条 8，反正都是 4 条轨道。

![Untitled](%E9%A2%98%E7%9B%AE%202b2a2772d43f4e09912b5cced62bb00b/Untitled%2021.png)

C。注意是 1 在队头，其实就是一道栈的题。3 输出时 1,2 没输出，则 12 逆序。

![Untitled](%E9%A2%98%E7%9B%AE%202b2a2772d43f4e09912b5cced62bb00b/Untitled%2022.png)

D。排除法

队列应用

![Untitled](%E9%A2%98%E7%9B%AE%202b2a2772d43f4e09912b5cced62bb00b/Untitled%2023.png)